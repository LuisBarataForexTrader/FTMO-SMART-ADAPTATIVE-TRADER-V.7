//+------------------------------------------------------------------+
//| SMART ADAPTATIVE TRADER 9.1               
//+------------------------------------------------------------------+
#property copyright "SMART ADAPTATIVE TRADER 9.1"
#property link      ""
#property version   "9.1"
#property strict

#include <Trade/Trade.mqh>

// ===================== CONFIGURAÇÃO PRINCIPAL =====================
input string AccountID = "CHANGE_THIS"; // CRÍTICO: MUDAR PARA CADA CONTA!

// ===================== CONFIGURAÇÃO DA ESTRATÉGIA =================
input int    RSIPeriod      = 14;
input double RSI_Overbought = 67;
input double RSI_Oversold   = 34;
input int    EMA_Fast       = 5;
input int    EMA_Slow       = 250;
input double BaseRisk       = 0.39;
input int    BaseSL         = 100;
input int    BaseTP         = 150;

// ===================== SISTEMA DE STEALTH =========================
input bool   EnableStealth          = true;
input int    StealthLevel           = 3;         // 1=Basic, 2=Advanced, 3=Ultra
input bool   EnableRandomDelays     = true;
input int    MinDelaySeconds        = 0;
input int    MaxDelaySeconds        = 15;
input bool   EnableTradeSkipping    = true;
input int    SkipTradePercent       = 20;
input bool   EnableDynamicSLTP      = true;
input bool   EnableMagicRotation    = true;
input int    MagicRotationTrades    = 10;
input bool   EnableParameterRandom  = true;
input double MaxRiskVariation       = 3.0;
input double MaxSLVariation         = 4.0;
input double MaxTPVariation         = 4.0;

// ===================== GESTÃO DE RISCO ============================
input int    MaxDailyTrades         = 5;
input int    MinTimeBetweenTrades   = 180;
input double MaxDailyLoss           = 2.0;
input double MaxTotalLoss           = 6.0;

// ===================== VARIÁVEIS GLOBAIS ==========================
CTrade Trade;
int rsiHandle, emaFastHandle, emaSlowHandle;
datetime lastBarTime = 0;
datetime lastTradeTime = 0;
int currentMagic = 0;
int tradesToday = 0;
double dailyPnL = 0;
datetime dayReset = 0;

// Variáveis stealth
int stealthDelay = 0;
bool skipThisTrade = false;
double stealthRiskMod = 1.0;
double stealthSLMod = 1.0;
double stealthTPMod = 1.0;

//+------------------------------------------------------------------+
//| INITIALIZATION                                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // Validação
   string accID = AccountID;
   if(accID == "CHANGE_THIS" || accID == "")
   {
      Alert("ERRO: AccountID deve ser único para cada conta!");
      return INIT_PARAMETERS_INCORRECT;
   }
   
   // Inicializar indicadores
   rsiHandle = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);
   emaFastHandle = iMA(_Symbol, _Period, EMA_Fast, 0, MODE_EMA, PRICE_CLOSE);
   emaSlowHandle = iMA(_Symbol, _Period, EMA_Slow, 0, MODE_EMA, PRICE_CLOSE);
   
   // Gerar magic number
   currentMagic = GenerateStealthMagic();
   Trade.SetExpertMagicNumber(currentMagic);
   Trade.SetDeviationInPoints(10);
   Trade.SetAsyncMode(true);
   
   // Inicializar random
   MathSrand((uint)(TimeLocal() + AccountInfoInteger(ACCOUNT_LOGIN)));
   
   // Reset diário
   ResetDaily();
   
   // Print
   Print("=== ALPHA STEALTH EA ===");
   Print("Account: ", accID);
   Print("Magic: ", currentMagic);
   Print("Stealth Level: ", StealthLevel);
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| GERAR MAGIC NUMBER                                               |
//+------------------------------------------------------------------+
int GenerateStealthMagic()
{
   string accID = AccountID;
   
   // Hash do AccountID
   int uidHash = 0;
   for(int i = 0; i < StringLen(accID); i++)
      uidHash = uidHash * 31 + accID[i];
   
   // Data/hora
   MqlDateTime dt;
   TimeCurrent(dt);
   int timeHash = dt.hour * 3600 + dt.min * 60 + dt.sec;
   
   // Símbolo
   int symHash = 0;
   string symbol = Symbol();
   for(int i = 0; i < StringLen(symbol); i++)
      symHash += symbol[i] * (i + 1);
   
   // Timeframe
   int tfHash = (int)Period() * 7919;
   
   // Account number
   long accountNumber = AccountInfoInteger(ACCOUNT_LOGIN);
   int accHash = (int)(accountNumber % 10000);
   
   // Random
   int dailyRandom = MathRand() % 1000;
   
   // Combinar
   int magic = 1000000;
   magic ^= (uidHash % 100000);
   magic ^= (timeHash % 10000) * 100;
   magic ^= (symHash % 1000) * 10;
   magic ^= tfHash % 1000;
   magic ^= accHash;
   magic ^= dailyRandom;
   
   // Ajustar
   magic = MathAbs(magic) % 1000000;
   if(magic < 100000) magic += 100000;
   
   return magic;
}

//+------------------------------------------------------------------+
//| RESET DIÁRIO                                                     |
//+------------------------------------------------------------------+
void ResetDaily()
{
   tradesToday = 0;
   dailyPnL = 0;
   MqlDateTime dt;
   TimeCurrent(dt);
   dt.hour = 0;
   dt.min = 0;
   dt.sec = 0;
   dayReset = StructToTime(dt) + 86400;
}

//+------------------------------------------------------------------+
//| APLICAR STEALTH                                                  |
//+------------------------------------------------------------------+
void ApplyStealth()
{
   skipThisTrade = false;
   stealthDelay = 0;
   stealthRiskMod = 1.0;
   stealthSLMod = 1.0;
   stealthTPMod = 1.0;
   
   if(!EnableStealth) return;
   
   // Random delays
   if(EnableRandomDelays && StealthLevel >= 1)
   {
      stealthDelay = MinDelaySeconds + (MathRand() % (MaxDelaySeconds - MinDelaySeconds + 1));
   }
   
   // Trade skipping
   if(EnableTradeSkipping && StealthLevel >= 2)
   {
      if(MathRand() % 100 < SkipTradePercent)
      {
         skipThisTrade = true;
         Print("Trade skipped (stealth)");
         return;
      }
   }
   
   // Parameter randomization
   if(EnableParameterRandom && StealthLevel >= 2)
   {
      double riskVar = 1.0 + ((MathRand() % (int)(MaxRiskVariation * 2 + 1)) - MaxRiskVariation) / 100.0;
      stealthRiskMod = riskVar;
      
      double slVar = 1.0 + ((MathRand() % (int)(MaxSLVariation * 2 + 1)) - MaxSLVariation) / 100.0;
      stealthSLMod = slVar;
      
      double tpVar = 1.0 + ((MathRand() % (int)(MaxTPVariation * 2 + 1)) - MaxTPVariation) / 100.0;
      stealthTPMod = tpVar;
   }
   
   // Magic rotation
   if(EnableMagicRotation && StealthLevel >= 3)
   {
      if(tradesToday > 0 && tradesToday % MagicRotationTrades == 0)
      {
         currentMagic = GenerateStealthMagic();
         Trade.SetExpertMagicNumber(currentMagic);
         Print("Magic rotated: ", currentMagic);
      }
   }
}

//+------------------------------------------------------------------+
//| CHECK TRADING CONDITIONS                                         |
//+------------------------------------------------------------------+
bool CanTrade()
{
   // Daily reset
   if(TimeCurrent() >= dayReset)
      ResetDaily();
   
   // Daily loss check
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   
   if(balance > 0)
   {
      double dailyLossPct = ((equity - balance) / balance) * 100.0;
      if(dailyLossPct <= -MaxDailyLoss)
      {
         Print("Daily loss limit: ", DoubleToString(dailyLossPct, 2), "%");
         return false;
      }
   }
   
   // Max daily trades
   if(tradesToday >= MaxDailyTrades)
   {
      Print("Max trades: ", tradesToday, "/", MaxDailyTrades);
      return false;
   }
   
   // Time between trades
   int timeSinceLast = (int)(TimeCurrent() - lastTradeTime);
   if(timeSinceLast < MinTimeBetweenTrades)
      return false;
   
   // Apply stealth
   ApplyStealth();
   
   if(skipThisTrade)
      return false;
   
   return true;
}

//+------------------------------------------------------------------+
//| CALCULATE LOT SIZE                                               |
//+------------------------------------------------------------------+
double CalculateLotSize()
{
   double risk = BaseRisk * stealthRiskMod;
   
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = balance * (risk / 100.0);
   
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   if(tickValue == 0 || tickSize == 0 || point == 0)
      return 0.01;
   
   double slPips = BaseSL * stealthSLMod;
   double riskPerLot = slPips * point * tickValue / tickSize;
   
   if(riskPerLot == 0)
      return 0.01;
   
   double lots = riskAmount / riskPerLot;
   
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   if(lotStep > 0)
   {
      if(StealthLevel >= 2 && MathRand() % 100 < 50)
         lots = MathCeil(lots / lotStep) * lotStep;
      else
         lots = MathFloor(lots / lotStep) * lotStep;
   }
   
   lots = MathMax(minLot, MathMin(maxLot, lots));
   
   return NormalizeDouble(lots, 2);
}

//+------------------------------------------------------------------+
//| GET TRADING SIGNAL                                               |
//+------------------------------------------------------------------+
int GetSignal()
{
   double rsi[1], emaFast[1], emaSlow[1];
   
   if(CopyBuffer(rsiHandle, 0, 0, 1, rsi) != 1) return 0;
   if(CopyBuffer(emaFastHandle, 0, 0, 1, emaFast) != 1) return 0;
   if(CopyBuffer(emaSlowHandle, 0, 0, 1, emaSlow) != 1) return 0;
   
   if(rsi[0] < RSI_Oversold && emaFast[0] > emaSlow[0])
      return 1;
   
   if(rsi[0] > RSI_Overbought && emaFast[0] < emaSlow[0])
      return 2;
   
   return 0;
}

//+------------------------------------------------------------------+
//| EXECUTE TRADE                                                    |
//+------------------------------------------------------------------+
void ExecuteTrade(int signal)
{
   if(!CanTrade())
      return;
   
   if(stealthDelay > 0)
      Sleep(stealthDelay * 1000);
   
   double lotSize = CalculateLotSize();
   if(lotSize <= 0)
      return;
   
   double price = (signal == 1) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
                                  SymbolInfoDouble(_Symbol, SYMBOL_BID);
   
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double slPips = BaseSL * stealthSLMod;
   double tpPips = BaseTP * stealthTPMod;
   
   if(EnableDynamicSLTP && StealthLevel >= 3)
   {
      bool opened = false;
      
      if(signal == 1)
         opened = Trade.Buy(lotSize, _Symbol, price, 0, 0);
      else
         opened = Trade.Sell(lotSize, _Symbol, price, 0, 0);
      
      if(opened)
      {
         Sleep(2000 + MathRand() % 6000);
         ApplyDynamicSLTP(signal, slPips, tpPips);
      }
   }
   else
   {
      double slPrice = (signal == 1) ? price - slPips * point : price + slPips * point;
      double tpPrice = (signal == 1) ? price + tpPips * point : price - tpPips * point;
      
      if(StealthLevel >= 2)
      {
         double adj = (MathRand() % 5 - 2) * point;
         slPrice += adj;
         tpPrice += adj;
      }
      
      if(signal == 1)
         Trade.Buy(lotSize, _Symbol, price, slPrice, tpPrice);
      else
         Trade.Sell(lotSize, _Symbol, price, slPrice, tpPrice);
   }
   
   tradesToday++;
   lastTradeTime = TimeCurrent();
   
   Print("Trade #", tradesToday, " ", (signal == 1 ? "BUY" : "SELL"), 
         " Magic:", currentMagic);
}

//+------------------------------------------------------------------+
//| APPLY DYNAMIC SL/TP                                              |
//+------------------------------------------------------------------+
void ApplyDynamicSLTP(int signal, double slPips, double tpPips)
{
   if(PositionsTotal() == 0) return;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionSelectByTicket(ticket))
      {
         if(PositionGetInteger(POSITION_MAGIC) == currentMagic)
         {
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
            
            double slPrice = 0, tpPrice = 0;
            
            if(signal == 1)
            {
               slPrice = openPrice - slPips * point;
               tpPrice = openPrice + tpPips * point;
            }
            else
            {
               slPrice = openPrice + slPips * point;
               tpPrice = openPrice - tpPips * point;
            }
            
            if(StealthLevel >= 2)
            {
               double adj = (MathRand() % 5 - 2) * point;
               slPrice += adj;
               tpPrice += adj;
            }
            
            Trade.PositionModify(ticket, slPrice, tpPrice);
            break;
         }
      }
   }
}

//+------------------------------------------------------------------+
//| ONTICK                                                           |
//+------------------------------------------------------------------+
void OnTick()
{
   if(PositionsTotal() > 0)
      return;
   
   datetime barTime = iTime(_Symbol, _Period, 0);
   if(barTime == lastBarTime)
      return;
   
   if(EnableRandomDelays && StealthLevel >= 2)
   {
      int reactionDelay = MathRand() % 6;
      if(reactionDelay > 0)
         Sleep(reactionDelay * 1000);
   }
   
   lastBarTime = barTime;
   
   int signal = GetSignal();
   if(signal == 0)
      return;
   
   ExecuteTrade(signal);
}

//+------------------------------------------------------------------+
//| DEINIT                                                           |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   if(rsiHandle != INVALID_HANDLE) IndicatorRelease(rsiHandle);
   if(emaFastHandle != INVALID_HANDLE) IndicatorRelease(emaFastHandle);
   if(emaSlowHandle != INVALID_HANDLE) IndicatorRelease(emaSlowHandle);
   
   Print("EA stopped. Trades: ", tradesToday);
}
