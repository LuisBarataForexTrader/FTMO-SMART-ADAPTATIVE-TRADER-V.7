//+------------------------------------------------------------------+
//| FTMO SMART ADAPTATIVE TRADER V.7                                 |
//+------------------------------------------------------------------+
#property strict
#property version "6.1"
#property description "EA adaptativo para Prop Firms – presets Alpha uniformes, Stealth, RealAccountMode"

//====================================================================
// INCLUDES
//====================================================================
#include <Trade\Trade.mqh>
CTrade trade;

//====================================================================
// ENUMS
//====================================================================
enum PropFirm { FTMO=0, ALPHA=1, FUNDEDNEXT=2, THE5ERS=3 };
enum Phase    { PHASE1=0, PHASE2=1 };

//====================================================================
// INPUTS
//====================================================================
input PropFirm SelectedPropFirm   = FTMO;
input Phase    ChallengePhase     = PHASE1;  // Fase do challenge
input bool     RealAccountMode    = false;   // True = conta real após fase 2
input int      MagicNumber        = 202512;

// STRATEGY PARAMETERS
input int RSIPeriod       = 14;
input double RSI_OB       = 68;
input double RSI_OS       = 33;
input int EMAFastPeriod   = 16;
input int EMASlowPeriod   = 200;

// ADAPTIVE FILTERS
input int ADXPeriod             = 14;
input double ADX_Min            = 14;
input double ADX_Full           = 20;
input int EMASlopeLookback      = 20;
input double ATR_Min_Percent    = 0.10;
input double ATR_Max_Percent    = 0.50;

// TRADE PARAMETERS
double Risk = 0.7;                   // Valor Alpha mais alto para challenge
double BaseSL_Pips = 100;
double BaseTP_Pips = 150;
double TargetProfitPct = 10;
double DailyDDLimit = 0.05;
double MaxDDLimit   = 0.10;
double MaxConsecutiveLosses = 2;
input double MaxSpread = 10;

// STEALTH MODE
input bool   EnableStealth = true;
input double RiskRandom    = 0.05;
input double SLTPRandom    = 0.05;

// REAL ACCOUNT SCALING
input bool   EnableScaling  = true;
input double AccountMultiplier = 1.0;

//====================================================================
// HANDLES
//====================================================================
int rsiH, emaFastH, emaSlowH, adxH, atrH;

//====================================================================
// VARIABLES
//====================================================================
datetime lastBarTime = 0;
datetime lastTradeTime = 0;

//====================================================================
// INIT
//====================================================================
int OnInit()
{
   rsiH      = iRSI(_Symbol,_Period,RSIPeriod,PRICE_CLOSE);
   emaFastH  = iMA(_Symbol,_Period,EMAFastPeriod,0,MODE_EMA,PRICE_CLOSE);
   emaSlowH  = iMA(_Symbol,_Period,EMASlowPeriod,0,MODE_EMA,PRICE_CLOSE);
   adxH      = iADX(_Symbol,_Period,ADXPeriod);
   atrH      = iATR(_Symbol,_Period,14);

   MathSrand((uint)TimeLocal());

   SetPreset();

   return INIT_SUCCEEDED;
}

//====================================================================
// SET PRESETS AUTOMATICAMENTE
//====================================================================
void SetPreset()
{
   if(RealAccountMode)
   {
      Risk = 0.50;                   // aumento de risco na conta real
      BaseSL_Pips = 90;
      BaseTP_Pips = 140;
      TargetProfitPct = 0;
      DailyDDLimit = 0.05;
      MaxDDLimit   = 0.10;
      MaxConsecutiveLosses = 2;
   }
   else
   {
      // Fases de challenge: todos iguais, valores mais altos da Alpha
      Risk = 0.7;
      BaseSL_Pips = 100;
      BaseTP_Pips = 150;
      TargetProfitPct = 10;
      DailyDDLimit = 0.05;
      MaxDDLimit   = 0.10;
      MaxConsecutiveLosses = 2;
   }
}

//====================================================================
// UTILITIES
//====================================================================
bool HasPosition() { return PositionsTotal() > 0; }
bool SpreadOK()   { return SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) <= MaxSpread*10; }

//====================================================================
// MARKET REGIME ADAPTIVE
//====================================================================
bool MarketRegime(double &riskFactor)
{
   riskFactor = 1.0;

   double adx[1], atr[1], emaNow[1], emaPast[1];
   if(CopyBuffer(adxH,0,0,1,adx)!=1) return false;
   if(CopyBuffer(atrH,0,0,1,atr)!=1) return false;
   if(CopyBuffer(emaSlowH,0,0,1,emaNow)!=1) return false;
   if(CopyBuffer(emaSlowH,0,EMASlopeLookback,1,emaPast)!=1) return false;

   if(adx[0] < ADX_Min) return false;
   else if(adx[0] < ADX_Full) riskFactor *= 0.5;

   double slope = MathAbs(emaNow[0]-emaPast[0])/SymbolInfoDouble(_Symbol,SYMBOL_POINT);
   double atrPct = (atr[0]/SymbolInfoDouble(_Symbol,SYMBOL_BID))*100;
   double slopeRatio = slope/atrPct;

   if(slopeRatio < 0.25) return false;
   else if(slopeRatio < 0.6) riskFactor *= 0.5;

   if(atrPct < ATR_Min_Percent || atrPct > ATR_Max_Percent) riskFactor *= 0.6;

   return true;
}

//====================================================================
// SIGNAL
//====================================================================
int Signal()
{
   double r[1], ef[1], es[1];
   if(CopyBuffer(rsiH,0,0,1,r)!=1) return -1;
   if(CopyBuffer(emaFastH,0,0,1,ef)!=1) return -1;
   if(CopyBuffer(emaSlowH,0,0,1,es)!=1) return -1;

   if(r[0] < RSI_OS && ef[0] > es[0]) return ORDER_TYPE_BUY;
   if(r[0] > RSI_OB && ef[0] < es[0]) return ORDER_TYPE_SELL;

   return -1;
}

//====================================================================
// LOT CALCULATION
//====================================================================
double CalculateLot(double riskFactor)
{
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);

   if(RealAccountMode && EnableScaling) equity *= AccountMultiplier;

   double adjRisk = Risk * riskFactor;
   if(RealAccountMode) adjRisk *= 1.0; // risco real 50%

   if(EnableStealth)
      adjRisk += ((MathRand()%100)/100.0*RiskRandom*2)-RiskRandom;

   double riskMoney = equity*(adjRisk/100.0);
   double tickVal   = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double tickSize  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
   double point     = SymbolInfoDouble(_Symbol,SYMBOL_POINT);

   double riskLot = BaseSL_Pips*point*tickVal/tickSize;
   double lot     = riskMoney/riskLot;

   double step = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);
   double minL = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);

   lot = MathFloor(lot/step)*step;
   return NormalizeDouble(MathMax(minL,lot),2);
}

//====================================================================
// TRADE EXECUTION
//====================================================================
void OpenTrade(int type,double riskFactor)
{
   double lot = CalculateLot(riskFactor);
   if(lot <= 0) return;

   double slP = BaseSL_Pips;
   double tpP = BaseTP_Pips;

   if(EnableStealth)
   {
      slP *= 1 + (((MathRand()%100)/100.0*SLTPRandom*2)-SLTPRandom);
      tpP *= 1 + (((MathRand()%100)/100.0*SLTPRandom*2)-SLTPRandom);
   }

   double price = (type==ORDER_TYPE_BUY)?SymbolInfoDouble(_Symbol,SYMBOL_ASK):SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double p = SymbolInfoDouble(_Symbol,SYMBOL_POINT);

   double sl = (type==ORDER_TYPE_BUY)? price-slP*p : price+slP*p;
   double tp = (type==ORDER_TYPE_BUY)? price+tpP*p : price-tpP*p;

   trade.SetExpertMagicNumber(MagicNumber);
   if(trade.PositionOpen(_Symbol,(ENUM_ORDER_TYPE)type,lot,price,sl,tp))
      lastTradeTime = TimeCurrent();
}

//====================================================================
// ON TICK
//====================================================================
void OnTick()
{
   if(!SpreadOK()) return;
   if(HasPosition()) return;
   if(TimeCurrent()-lastTradeTime < 1200) return;

   double riskFactor;
   if(!MarketRegime(riskFactor)) return;

   datetime bar = iTime(_Symbol,_Period,0);
   if(bar == lastBarTime) return;
   lastBarTime = bar;

   int sig = Signal();
   if(sig != -1)
      OpenTrade(sig,riskFactor);
}
